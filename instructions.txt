addi 	$rt0,$rs1,7  		00100000001000000000000000000111 -> $rt0=7, $rs1=0

addi 	$rt2,$rs1,6  		00100000001000100000000000000110 -> $rt2=6, $rs1=0

sub  	$rd3,$rt0,$rt2 		00000000000000100001100000100010 -> $rd3=7-6=1,$rt0=7,$rt2=6

sw 	$rt3,0($s5) 		10101100101000110000000000000000 -> MM[0+$s5]=$rt3=1

and 	$rt3,$rt3,$rt2 		00000000011000100001100000100100 -> $rt3 = 1 AND 6 = 0

slti 	$rt4,$rt3,2 		00101000011001000000000000000010 -> $rt3=0 < imm=2, $rt4 = 1

lw 	$rt6,0($s5) 		10001100101001100000000000000000 -> $rt6 = MM[0+$s5]=1

or 	$rt1,$rt6,$rt2 i_cache	00000000110000100000100000100101 -> $rt1 = 1 OR 6 = 7

xor 	$rt5,$rt1,$rt2 		00000000001000100010100000100110 -> $rt5 = 6 XOR 7 = 1

nor 	$rt5,$rt5,$rt2 		00000000101000100010100000100111 -> $rt5 = 0001 NOR 0006 = -8

andi 	$rt3,$rt2,4 		00110000010000110000000000000100 -> $rt3 = 6 ANDi 4 = 4

ori 	$rt3,$rt5,7 		00110100101000110000000000000111 -> $rt3 = -8 ORi 7 = -1

xori 	$rt3,$rt3,6 		00111000011000110000000000000110 -> $rt3 = -1 XORi 6 = -7

slt 	$rt4,$rt5,$rt3 		00000000101000110010000000101010 -> $rt4 = 1 --> -8 < -7

j 	target 			00001000000000000000000000010000 -> target = 10000

beq 	$rt4,$rt6,1 		00010000100001100000000000000001 -> if $rt4 == $rt6 then jump to ADD = 10001

bne 	$rt5,$rt3,(FFFE)	00010100101000111111111111111110 -> if $rt5 != $rt3 then jump back to the previous instruction

bltz 	$rt4,0 			00000100100000000000000000000000 -> branch all the way back to address 00000 if $rt4 < 0

lui 	$rt4,1 			00111100000001000000000000000001 -> $rt4 = 1 << 16 = (65536)10

add 	$rt4,$rt4,$rt4		00000000100001000010000000100000

jr 	$rt10 			00000001010000000000000000001000 -> jump to adress 00000 The whole program BEGINS executing again 





